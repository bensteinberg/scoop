import path from "path";
import * as zip from "../utils/zip.js";

import CONSTANTS from "../constants.js";

import { Readable, Writable } from "stream";
import { CDXIndexer } from "warcio";
import { createHash } from "crypto";

export class WACZ {
  validations = [
    [/^archives\//, [this.assertWarc]],
    [/^indexes\//, [this.assertIndex]],
    [/^pages\//, [this.assertPages]]
  ]

  assertWarc(fpath, fdata) {
    buf = Buffer.from(fdata);

    if(buf.toString('utf8', 0, 4) === 'WARC'){
        return;
    }

    if(zip.isZip(buf)){
      if(!/\.warc\.gz$/.test(fpath)) {
        throw `${fpath}: must use .warc.gz extension when using zip`
      } else if(!zip.usesStoreCompression(fdata)){
        throw `${fpath}: must use STORE when compressing the zip`
      } else if(zip.readBodyAsString(fdata, 4) === 'WARC') {
        return;
      }
    }

    throw `${fpath}: must be a valid WARC file`;
  }

  assertIndex(fpath, fdata) {
    const json = JSON.parse(Buffer.from(fdata).toString().split('\n')[0].split(/ \d{14} /)[1])
    if(!json.url){
      throw `${fpath}: must be a valid CDXJ file`;
    }
  }

  assertPages(fpath, fdata) {
    const lines = Buffer.from(fdata).toString().split('\n').map(JSON.parse);
    const entry = lines[lines.length - 1];
    if(!entry.url || !entry.ts) {
      throw `${fpath}: must be a valid JSON-Lines file with url and ts properties`;
    }
  }

  _filesProxy;

  get files() {
    if(!this._filesProxy){
      this.files = {}// initialize proxy
    }
    return this._filesProxy;
  }

  set files(obj) {
    Object.entries(obj).forEach(([fpath, fdata]) => {
      return this.validateFile(fpath, fdata);
    })

    this._filesProxy = new Proxy(obj, {
      set: (target, fpath, fdata) => {
        this.validateFile(fpath, fdata);
        target[fpath] = fdata;
        return true;
      }
    });
  }

  validateFile(fpath, fdata) {
    this.validations
        .filter(([regex]) => regex.test(fpath))
        .forEach(([,assertions]) => {
          assertions.forEach(assert => assert(fpath, fdata))
        });
  }

  pages = [];

  datapackage = {};

  async generateIndexCDX(files = this.files) {
    const buffers = [];
    const converter = new Writable();
    converter._write = (chunk, _encoding, cb) => {
      buffers.push(chunk)
      process.nextTick(cb)
    }

    const warcs = Object.entries(files)
                        .filter(([fpath]) => /^archive\//.test(fpath))
                        .map(([fpath, fdata]) => {
                          return {
                            filename: path.basename(fpath),
                            reader: Readable.from(fdata)
                          }
                        })

    await new CDXIndexer({format: 'cdxj'}, converter).run(warcs);
    return Buffer.concat(buffers);
  }

  generatePages() {
    const jsonStr = [{
      format: "json-pages-1.0",
      id: "pages",
      title: "All Pages"
    }].concat(this.pages)
      .map(JSON.stringify)
      .join('\n')

    return Buffer.from(jsonStr);
  }

  generateDatapackage() {
    return stringify({
      ...this.datapackage,
      profile: "data-package",
      wacz_version: CONSTANTS.WACZ_VERSION,
      software: CONSTANTS.SOFTWARE,
      created: (new Date()).toISOString(),
      resources: Object.entries(this.files).map(([fpath, fdata]) => {
        return {
          name: path.basename(fpath),
          path: fpath,
          hash: hash(fdata),
          bytes: fdata.byteLength
        }
      })
    })
  }

  generateDatapackageDigest() {
    if(!this.files["datapackage.json"]){
      throw "datapackage.json must be present to generate datapackage-digest.json"
    }

    return stringify({
      path: 'datapackage.json',
      hash: hash(this.files['datapackage.json'])
    });
  }

  async finalize(autoindex = true) {
    if(dirEmpty(this.files, "archive")){
      throw "at least one WARC must be present in the archive directory";
    }

    if(autoindex) {
      const index = await this.generateIndexCDX();
      this.files["indexes/index.cdx"] = index;
    } else if(dirEmpty(this.files, "indexes")){
      throw "at least one CDXJ index must be present in the indexes directory";
    }

    if(this.pages.length) {
      this.files['pages/pages.jsonl'] = this.generatePages();
    } else {
      throw "at least one page must be present";
    }

    // Always autogenerated
    this.files['datapackage.json'] = this.generateDatapackage();
    this.files['datapackage-digest.json'] = this.generateDatapackageDigest();

    return await zip.create(this.files);
  }

  constructor(props = {}) {
    // Only accept props that reflect a defined property of `this`
    for (const [key, value] of Object.entries(props)) {
      if (key in this) {
        this[key] = value;
      }
    }

    return this;
  }
}

// Internal helpers

const dirEmpty = (files, dir) => {
  const regex = new RegExp(`^${dir}\/.+`);
  return !Object.entries(files).find(([fpath]) => regex.test(fpath));
}

const hash = (buffer) => 'sha256:' + createHash('sha256').update(buffer).digest('hex');

const stringify = (obj) => JSON.stringify(obj, null, 2);

// Mischief helpers

export function mischiefExchangeToPageLine(exchange) {
  return {
    id: exchange.id,
    url: exchange.response.url,
    ts: exchange.date.toISOString(),
    title: exchange.description || `Web archive of ${exchange.response.url}`
  }
}
